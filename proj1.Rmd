---
title: "Statisitcal Programming - 2020 - Project 1"
output: rmarkdown::html_document
author: Add your name here
---

Due on Monday, November 2nd by 5:00 pm (17:00), UK local time.

Before you start be sure to read through *all* of the rules and instructions in the `README.md`.

<br/>

### Data

```{r}
library(tidyverse)
f1 = readRDS(file="data/f1.rds")
```


<br/>

### Task 1 - Tidy the data

#### Write up

In this task we mainly utilize the `hoist()` function to extract the relevant information
from the dataset before finishing with the `mutate()` function to convert the data
into the appropriate types. Note that the positions “R” (retired), “D” (disqualified), 
“E” (excluded),  “W” (withdrawn), “F” (failed to qualify) and “N” (not classified) 
provided in the original data have all been intentionally coerced into `NA` values
since all of these positions correspond to a driver failing to complete a race.

#### Code

```{r task1}
f1_tbl = tibble(f1_data = f1) %>%
  # ------------------ Pulling out relevant information ------------------ #
  unnest_wider(f1_data) %>%
  hoist(
    MRData,
    races = c('RaceTable', 'Races')
  ) %>% select(races) %>%
  unnest_longer(races) %>%
  hoist(
    races,
    race_name = c('raceName'),
    round = c('round'),
    date = (c('date')),
    results = c('Results')
  ) %>% select(-races) %>%
  unnest_longer(results) %>%
  hoist(
    results,
    first_name = c('Driver', 'givenName'),
    last_name = c('Driver', 'familyName'),
    constructor = c('Constructor', 'name'),
    position = c('positionText'),
    points = c('points')
    ) %>%
  # --------------- Mutating data to be of appropriate type -------------- #
  mutate(
    round = as.integer(round),
    date = as.Date(date),
    driver = paste(first_name, last_name),
    # Suppressing warning NA coercion is desired
    position = suppressWarnings(as.integer(position)),
    points = as.integer(points)
  ) %>% 
  select(race_name, round, date, driver, constructor, position, points)

print(head(f1_tbl, n = 10L))
```

<br/>


### Task 2 - Drivers' Championship

#### Write up

We begin our table creation by first selecting only the relevant columns. We then
proceed to calculate the F1 rankings for the 2019 season before pivoting wider
to make each row represent the positions of a single driver across the season.
Our table columns were renamed as well as the points tally relocated to the end
of the table in order improve the overall readability of the presentation.

#### Code

```{r task2}
# Defining new column names for easy reading
rankings_colnames = c('Driver', 'AUS', 'BHR', 'CHN', 'AZE', 'ESP', 'MON', 'CAN', 'FRA', 
             'AUT', 'GBR', 'GER', 'HUN', 'BEL', 'ITA', 'SIN', 'RUS', 'JPN', 'MEX',
             'USA', 'BRA', 'ABU', 'Points')

rankings_tbl = f1_tbl %>% 
  select(race_name, driver, position, points) %>%
  # Getting ranking for 2019 season for each driver
  group_by(driver) %>%
  mutate(points = sum(points)) %>%
  # 1 row = 1 driver
  pivot_wider(names_from = race_name, values_from = position) %>%
  arrange(desc(points)) %>%
  # Making points the last column
  relocate(points, .after = last_col())
  colnames(rankings_tbl) = rankings_colnames

knitr::kable(rankings_tbl)
```

<br/>

### Task 3 - Cumulative Constructors

#### Write up

We, as usual, begin by selecting only the relevant information. The data is structured
such that we have twice as many rows as required due to each constructor/team
having two representatives. We use this to our advantage and compute the sum of
points grouped by `race_name` and `constructor`. This produces duplicate entries in
our dataset which are easily removed using the `distinct()` function yielding
the points scored by each constructor at each race. Naturally, we can now apply
the `cumsum()` function column wise, pivot wider and sort by descending points 
to generate the required table. Again, renaming the columns was performed to 
improve the readability of the table and match the convention used in Task 2.

#### Code

```{r task3}
# Defining new column names for easy reading
team_colnames = c('Constructor', 'AUS', 'BHR', 'CHN', 'AZE', 'ESP', 'MON', 
                         'CAN', 'FRA',  'AUT', 'GBR', 'GER', 'HUN', 'BEL', 'ITA', 
                         'SIN', 'RUS', 'JPN', 'MEX', 'USA', 'BRA', 'ABU')

team_tbl = f1_tbl %>%
  select(race_name, constructor, points) %>%
  # Getting points scored by each constructor at each race
  group_by(constructor, race_name) %>%
  mutate(points = sum(points)) %>%
  distinct()  %>%
  # Performing cumulative sum of points over the season
  group_by(constructor) %>%
  mutate(points = cumsum(points)) %>%
  pivot_wider(names_from = race_name, values_from = points) %>%
  # Abu Dhabi = final race hence apply sorting here
  arrange(desc(`Abu Dhabi Grand Prix`))
colnames(team_tbl) = team_colnames

knitr::kable(team_tbl)
```


<br/>

### Task 4 - Visualization

#### Write up

<!-- Include write up here -->

#### Code

```{r task4}
race_levels = c("Australian Grand Prix", "Bahrain Grand Prix", "Chinese Grand Prix",
                "Azerbaijan Grand Prix", "Spanish Grand Prix", "Monaco Grand Prix",
                "Canadian Grand Prix", "French Grand Prix", "Austrian Grand Prix",
                "British Grand Prix", "German Grand Prix", "Hungarian Grand Prix",
                "Belgian Grand Prix", "Italian Grand Prix", "Singapore Grand Prix",
                "Russian Grand Prix", "Japanese Grand Prix", "Mexican Grand Prix",
                "United States Grand Prix", "Brazilian Grand Prix", "Abu Dhabi Grand Prix")

# Creating analagous tibble to task 3 for the drivers
driver_tbl = f1_tbl %>%
  select(race_name, driver, points) %>%
  # Getting points scored by each driver at each race
  group_by(driver, race_name) %>%
  mutate(points = sum(points)) %>%
  # Performing cumulative sum of points over the season
  group_by(driver) %>%
  mutate(points = cumsum(points)) %>%
  mutate(race_name = factor(race_name, levels = race_levels))
driver_tbl

#factor(rankings_colnames[c(-1, -length(rankings_colnames))], rankings_colnames[c(-1, -length(rankings_colnames))])

#%>%
#  pivot_wider(names_from = race_name, values_from = points) %>%
#  # Abu Dhabi = final race hence apply sorting here
#  arrange(desc(`Abu Dhabi Grand Prix`))
#colnames(driver_tbl) = rankings_colnames[-length(rankings_colnames)]

ggplot(data=driver_tbl, aes(x=race_name, y=points, group=driver)) +
  geom_line() + 
  geom_point() + 
  scale_x_discrete(
    name = "Race",
    labels = team_colnames[-1]
    )

```

<br/>

